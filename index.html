<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OBJ Color Clamper</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #e0e0e0;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #f39c12, #e74c3c);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card h2 {
      font-size: 1.2rem;
      margin-bottom: 16px;
      color: #f39c12;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card h2::before {
      content: '';
      width: 4px;
      height: 20px;
      background: #f39c12;
      border-radius: 2px;
    }

    /* File Upload */
    .file-drop-zone {
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .file-drop-zone:hover, .file-drop-zone.dragover {
      border-color: #f39c12;
      background: rgba(243, 156, 18, 0.1);
    }

    .file-drop-zone input {
      display: none;
    }

    .file-drop-zone .icon {
      font-size: 48px;
      margin-bottom: 10px;
    }

    .file-info {
      margin-top: 15px;
      padding: 12px;
      background: rgba(46, 204, 113, 0.2);
      border-radius: 8px;
      display: none;
    }

    .file-info.show {
      display: block;
    }

    /* Color Pool */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .color-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      font-size: 0.85rem;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    /* Parameters */
    .params-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 600px) {
      .params-grid {
        grid-template-columns: 1fr;
      }
    }

    .param-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .param-group label {
      font-weight: 500;
      color: #ccc;
    }

    .param-group input[type="number"] {
      padding: 12px 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 1rem;
      width: 100%;
    }

    .param-group input:focus {
      outline: none;
      border-color: #f39c12;
    }

    .param-help {
      font-size: 0.8rem;
      color: #888;
    }

    /* Process Button */
    .btn-process {
      width: 100%;
      padding: 16px 32px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      background: linear-gradient(90deg, #f39c12, #e74c3c);
      color: white;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .btn-process:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(243, 156, 18, 0.3);
    }

    .btn-process:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Progress */
    .progress-container {
      display: none;
      margin-top: 20px;
    }

    .progress-container.show {
      display: block;
    }

    .progress-bar {
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #f39c12, #e74c3c);
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-text {
      margin-top: 10px;
      text-align: center;
      color: #888;
    }

    /* Results */
    .results {
      display: none;
    }

    .results.show {
      display: block;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat-item {
      padding: 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      text-align: center;
    }

    .stat-item .color-preview {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      margin: 0 auto 10px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .stat-item .name {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .stat-item .count {
      color: #888;
      font-size: 0.9rem;
    }

    .btn-download {
      width: 100%;
      padding: 16px 32px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      background: linear-gradient(90deg, #2ecc71, #27ae60);
      color: white;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .btn-download:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(46, 204, 113, 0.3);
    }

    /* Log */
    .log-container {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 16px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.85rem;
      line-height: 1.6;
    }

    .log-container::-webkit-scrollbar {
      width: 8px;
    }

    .log-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .log-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    .log-line {
      color: #888;
    }

    .log-line.info {
      color: #3498db;
    }

    .log-line.success {
      color: #2ecc71;
    }

    .log-line.highlight {
      color: #f39c12;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé® OBJ Color Clamper</h1>
    <p class="subtitle">Reduce vertex colors to a limited palette for 3D printing</p>

    <!-- File Upload -->
    <div class="card">
      <h2>1. Select OBJ File</h2>
      <div class="file-drop-zone" id="dropZone">
        <div class="icon">üìÅ</div>
        <div>Drop your OBJ file here or <strong>click to browse</strong></div>
        <input type="file" id="fileInput" accept=".obj">
      </div>
      <div class="file-info" id="fileInfo">
        <strong id="fileName"></strong><br>
        <span id="fileStats"></span>
      </div>
    </div>

    <!-- Color Pool -->
    <div class="card">
      <h2>2. Available Colors</h2>
      <div class="color-grid" id="colorPool"></div>
    </div>

    <!-- Parameters -->
    <div class="card">
      <h2>3. Parameters</h2>
      <div class="params-grid">
        <div class="param-group">
          <label for="numColors">Number of Colors</label>
          <input type="number" id="numColors" value="4" min="1" max="13">
          <span class="param-help">How many colors to use (1-13)</span>
        </div>
        <div class="param-group">
          <label for="islandThreshold">Island Threshold</label>
          <input type="number" id="islandThreshold" value="10" min="1" max="1000">
          <span class="param-help">Merge isolated regions smaller than this</span>
        </div>
      </div>
    </div>

    <!-- Process Button -->
    <div class="card">
      <button class="btn-process" id="processBtn" disabled>
        <span>‚öôÔ∏è</span> Process OBJ
      </button>
      <div class="progress-container" id="progressContainer">
        <div class="progress-bar">
          <div class="progress-bar-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Processing...</div>
      </div>
    </div>

    <!-- Results -->
    <div class="card results" id="resultsCard">
      <h2>4. Results</h2>
      <div class="stats-grid" id="statsGrid"></div>
      <button class="btn-download" id="downloadBtn">
        <span>üíæ</span> Download Processed OBJ
      </button>
    </div>

    <!-- Log -->
    <div class="card results" id="logCard">
      <h2>Processing Log</h2>
      <div class="log-container" id="logContainer"></div>
    </div>
  </div>

  <script>
    // ========================================================================
    // Color Class & Pool
    // ========================================================================

    class Color {
      constructor(r, g, b, name = null) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.name = name;
      }

      distanceTo(other) {
        const dr = this.r - other.r;
        const dg = this.g - other.g;
        const db = this.b - other.b;
        return Math.sqrt(2 * dr * dr + 4 * dg * dg + 3 * db * db);
      }

      clone() {
        return new Color(this.r, this.g, this.b, this.name);
      }

      toHex() {
        const toHex = (v) => Math.round(v * 255).toString(16).padStart(2, '0');
        return `#${toHex(this.r)}${toHex(this.g)}${toHex(this.b)}`;
      }
    }

    const COLOR_POOL = [
      new Color(1.0, 1.0, 1.0, 'white'),
      new Color(0.0, 0.0, 0.0, 'black'),
      new Color(0.9, 0.1, 0.1, 'red'),
      new Color(1.0, 0.5, 0.0, 'orange'),
      new Color(1.0, 0.9, 0.0, 'yellow'),
      new Color(0.2, 0.7, 0.2, 'green'),
      new Color(0.35, 0.2, 0.1, 'dark_brown'),
      new Color(0.65, 0.45, 0.25, 'light_brown'),
      new Color(0.96, 0.92, 0.82, 'cream'),
      new Color(0.1, 0.2, 0.5, 'dark_blue'),
      new Color(0.4, 0.7, 0.9, 'light_blue'),
      new Color(0.5, 0.5, 0.5, 'gray'),
      new Color(1.0, 0.6, 0.7, 'pink'),
    ];

    // ========================================================================
    // UI Elements
    // ========================================================================

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileStats = document.getElementById('fileStats');
    const processBtn = document.getElementById('processBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const resultsCard = document.getElementById('resultsCard');
    const logCard = document.getElementById('logCard');
    const statsGrid = document.getElementById('statsGrid');
    const downloadBtn = document.getElementById('downloadBtn');
    const logContainer = document.getElementById('logContainer');
    const colorPool = document.getElementById('colorPool');

    let loadedFile = null;
    let processedContent = null;

    // ========================================================================
    // Initialize Color Pool Display
    // ========================================================================

    COLOR_POOL.forEach(color => {
      const div = document.createElement('div');
      div.className = 'color-item';
      div.innerHTML = `
        <div class="color-swatch" style="background: ${color.toHex()}"></div>
        <span>${color.name}</span>
      `;
      colorPool.appendChild(div);
    });

    // ========================================================================
    // File Handling
    // ========================================================================

    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.name.endsWith('.obj')) {
        handleFile(file);
      }
    });

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        handleFile(file);
      }
    });

    function handleFile(file) {
      loadedFile = file;
      fileName.textContent = file.name;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const content = e.target.result;
        const lines = content.split('\n');
        const vertexCount = lines.filter(l => l.trim().startsWith('v ')).length;
        const faceCount = lines.filter(l => l.trim().startsWith('f ')).length;
        fileStats.textContent = `${vertexCount.toLocaleString()} vertices, ${faceCount.toLocaleString()} faces`;
        fileInfo.classList.add('show');
        processBtn.disabled = false;
      };
      reader.readAsText(file);
    }

    // ========================================================================
    // Logging
    // ========================================================================

    function log(message, type = '') {
      const line = document.createElement('div');
      line.className = `log-line ${type}`;
      line.textContent = message;
      logContainer.appendChild(line);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function clearLog() {
      logContainer.innerHTML = '';
    }

    // ========================================================================
    // OBJ Processing
    // ========================================================================

    function parseOBJ(content) {
      const lines = content.split('\n');
      const vertices = [];
      const vertexLineIndices = [];
      const faces = [];

      lines.forEach((line, index) => {
        const trimmed = line.trim();

        if (trimmed.startsWith('v ')) {
          const parts = trimmed.split(/\s+/);
          const x = parseFloat(parts[1]);
          const y = parseFloat(parts[2]);
          const z = parseFloat(parts[3]);

          let color = null;
          if (parts.length >= 7) {
            let r = parseFloat(parts[4]);
            let g = parseFloat(parts[5]);
            let b = parseFloat(parts[6]);

            if (r > 1 || g > 1 || b > 1) {
              r /= 255;
              g /= 255;
              b /= 255;
            }

            color = new Color(
              Math.max(0, Math.min(1, r)),
              Math.max(0, Math.min(1, g)),
              Math.max(0, Math.min(1, b))
            );
          }

          vertices.push({ x, y, z, color, lineIndex: index });
          vertexLineIndices.push(index);
        }

        if (trimmed.startsWith('f ')) {
          const parts = trimmed.split(/\s+/).slice(1);
          const faceVertices = parts.map(p => {
            const idx = parseInt(p.split('/')[0]);
            return idx > 0 ? idx - 1 : vertices.length + idx;
          });
          faces.push(faceVertices);
        }
      });

      return { vertices, vertexLineIndices, originalLines: lines, faces };
    }

    function buildVertexAdjacency(vertexCount, faces) {
      const adjacency = new Map();
      for (let i = 0; i < vertexCount; i++) {
        adjacency.set(i, new Set());
      }

      for (const face of faces) {
        for (let i = 0; i < face.length; i++) {
          for (let j = i + 1; j < face.length; j++) {
            const v1 = face[i];
            const v2 = face[j];
            if (v1 >= 0 && v1 < vertexCount && v2 >= 0 && v2 < vertexCount) {
              adjacency.get(v1).add(v2);
              adjacency.get(v2).add(v1);
            }
          }
        }
      }

      return adjacency;
    }

    function buildFaceAdjacency(faces) {
      const edgeToFaces = new Map();

      for (let faceIdx = 0; faceIdx < faces.length; faceIdx++) {
        const face = faces[faceIdx];
        for (let i = 0; i < face.length; i++) {
          const v1 = face[i];
          const v2 = face[(i + 1) % face.length];
          const edgeKey = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;

          if (!edgeToFaces.has(edgeKey)) {
            edgeToFaces.set(edgeKey, []);
          }
          edgeToFaces.get(edgeKey).push(faceIdx);
        }
      }

      const faceAdjacency = new Map();
      for (let i = 0; i < faces.length; i++) {
        faceAdjacency.set(i, new Set());
      }

      for (const faceIndices of edgeToFaces.values()) {
        if (faceIndices.length === 2) {
          faceAdjacency.get(faceIndices[0]).add(faceIndices[1]);
          faceAdjacency.get(faceIndices[1]).add(faceIndices[0]);
        }
      }

      return faceAdjacency;
    }

    function selectBestColors(vertexColors, poolColors, count) {
      const poolStats = poolColors.map(poolColor => ({
        color: poolColor,
        matchCount: 0,
        totalDistance: 0,
      }));

      for (const vertexColor of vertexColors) {
        let minDist = Infinity;
        let closestIdx = 0;

        for (let i = 0; i < poolColors.length; i++) {
          const dist = vertexColor.distanceTo(poolColors[i]);
          if (dist < minDist) {
            minDist = dist;
            closestIdx = i;
          }
        }

        poolStats[closestIdx].matchCount++;
        poolStats[closestIdx].totalDistance += minDist;
      }

      log('\nColor distribution:', 'info');
      const sortedStats = [...poolStats].sort((a, b) => b.matchCount - a.matchCount);
      for (const stat of sortedStats) {
        if (stat.matchCount > 0) {
          const avgDist = (stat.totalDistance / stat.matchCount).toFixed(3);
          log(`  ${stat.color.name}: ${stat.matchCount} vertices (avg dist: ${avgDist})`);
        }
      }

      return sortedStats
        .filter(s => s.matchCount > 0)
        .slice(0, count)
        .map(s => s.color);
    }

    function remapColors(vertices, palette) {
      const remapStats = {};
      palette.forEach(c => remapStats[c.name] = 0);

      for (const vertex of vertices) {
        if (!vertex.color) continue;

        let minDist = Infinity;
        let closestColor = palette[0];

        for (const paletteColor of palette) {
          const dist = vertex.color.distanceTo(paletteColor);
          if (dist < minDist) {
            minDist = dist;
            closestColor = paletteColor;
          }
        }

        vertex.color = closestColor.clone();
        remapStats[closestColor.name]++;
      }

      return remapStats;
    }

    function findColorIslands(vertices, adjacency) {
      const visited = new Set();
      const islands = [];

      for (let startIdx = 0; startIdx < vertices.length; startIdx++) {
        if (visited.has(startIdx)) continue;
        if (!vertices[startIdx].color) continue;

        const island = [];
        const queue = [startIdx];
        const colorName = vertices[startIdx].color.name;

        while (queue.length > 0) {
          const idx = queue.shift();
          if (visited.has(idx)) continue;

          const vertex = vertices[idx];
          if (!vertex.color || vertex.color.name !== colorName) continue;

          visited.add(idx);
          island.push(idx);

          for (const neighborIdx of adjacency.get(idx) || []) {
            if (!visited.has(neighborIdx)) {
              const neighbor = vertices[neighborIdx];
              if (neighbor.color && neighbor.color.name === colorName) {
                queue.push(neighborIdx);
              }
            }
          }
        }

        if (island.length > 0) {
          islands.push({
            vertices: island,
            colorName: colorName,
            color: vertices[startIdx].color.clone()
          });
        }
      }

      return islands;
    }

    function getNeighborColors(island, vertices, adjacency) {
      const neighborColors = new Map();

      for (const vertexIdx of island.vertices) {
        for (const neighborIdx of adjacency.get(vertexIdx) || []) {
          const neighbor = vertices[neighborIdx];
          if (!neighbor.color) continue;

          if (neighbor.color.name !== island.colorName) {
            const count = neighborColors.get(neighbor.color.name) || 0;
            neighborColors.set(neighbor.color.name, count + 1);
          }
        }
      }

      return neighborColors;
    }

    function mergeSmallIslands(vertices, adjacency, minIslandSize, palette) {
      let totalMerged = 0;
      let iterations = 0;
      const maxIterations = 10;

      while (iterations < maxIterations) {
        iterations++;
        const islands = findColorIslands(vertices, adjacency);
        islands.sort((a, b) => a.vertices.length - b.vertices.length);

        let mergedThisIteration = 0;

        for (const island of islands) {
          if (island.vertices.length >= minIslandSize) continue;

          const neighborColors = getNeighborColors(island, vertices, adjacency);
          if (neighborColors.size === 0) continue;

          let bestColor = null;
          let bestCount = 0;

          for (const [colorName, count] of neighborColors) {
            if (count > bestCount) {
              bestCount = count;
              bestColor = colorName;
            }
          }

          if (bestColor && bestColor !== island.colorName) {
            const newColor = palette.find(c => c.name === bestColor);
            if (newColor) {
              for (const vertexIdx of island.vertices) {
                vertices[vertexIdx].color = newColor.clone();
              }
              mergedThisIteration += island.vertices.length;
            }
          }
        }

        totalMerged += mergedThisIteration;
        if (mergedThisIteration === 0) break;
      }

      log(`  Merged ${totalMerged} vertices in ${iterations} iteration(s)`, 'success');
      return totalMerged;
    }

    function getFaceDominantColor(face, vertices) {
      const colorCounts = new Map();

      for (const vertexIdx of face) {
        const color = vertices[vertexIdx]?.color;
        if (color && color.name) {
          const count = colorCounts.get(color.name) || 0;
          colorCounts.set(color.name, count + 1);
        }
      }

      let dominant = null;
      let maxCount = 0;

      for (const [colorName, count] of colorCounts) {
        if (count > maxCount) {
          maxCount = count;
          dominant = colorName;
        }
      }

      return dominant;
    }

    function mergeIsolatedFaces(vertices, faces, faceAdjacency, minFaceIslandSize, palette) {
      let totalMerged = 0;
      let iterations = 0;
      const maxIterations = 10;

      while (iterations < maxIterations) {
        iterations++;

        const faceColors = faces.map(face => getFaceDominantColor(face, vertices));

        let mergedThisIteration = 0;

        // Step 1: Individual isolated faces
        for (let faceIdx = 0; faceIdx < faces.length; faceIdx++) {
          const myColor = faceColors[faceIdx];
          if (!myColor) continue;

          const neighbors = faceAdjacency.get(faceIdx) || new Set();
          if (neighbors.size === 0) continue;

          const neighborColorCounts = new Map();
          let hasNeighborWithSameColor = false;

          for (const neighborFace of neighbors) {
            const neighborColor = faceColors[neighborFace];
            if (!neighborColor) continue;

            if (neighborColor === myColor) {
              hasNeighborWithSameColor = true;
              break;
            }

            const count = neighborColorCounts.get(neighborColor) || 0;
            neighborColorCounts.set(neighborColor, count + 1);
          }

          if (!hasNeighborWithSameColor && neighborColorCounts.size > 0) {
            let bestColor = null;
            let bestCount = 0;

            for (const [colorName, count] of neighborColorCounts) {
              if (count > bestCount) {
                bestCount = count;
                bestColor = colorName;
              }
            }

            if (bestColor) {
              const newColor = palette.find(c => c.name === bestColor);
              if (newColor) {
                let changed = 0;
                for (const vertexIdx of faces[faceIdx]) {
                  if (vertices[vertexIdx].color?.name === myColor) {
                    vertices[vertexIdx].color = newColor.clone();
                    changed++;
                  }
                }
                if (changed > 0) {
                  mergedThisIteration += changed;
                }
              }
            }
          }
        }

        // Step 2: Face islands
        const updatedFaceColors = faces.map(face => getFaceDominantColor(face, vertices));
        const visited = new Set();
        const faceIslands = [];

        for (let startFace = 0; startFace < faces.length; startFace++) {
          if (visited.has(startFace)) continue;
          if (!updatedFaceColors[startFace]) continue;

          const island = [];
          const queue = [startFace];
          const colorName = updatedFaceColors[startFace];

          while (queue.length > 0) {
            const faceIdx = queue.shift();
            if (visited.has(faceIdx)) continue;
            if (updatedFaceColors[faceIdx] !== colorName) continue;

            visited.add(faceIdx);
            island.push(faceIdx);

            for (const neighborFace of faceAdjacency.get(faceIdx) || []) {
              if (!visited.has(neighborFace) && updatedFaceColors[neighborFace] === colorName) {
                queue.push(neighborFace);
              }
            }
          }

          if (island.length > 0) {
            faceIslands.push({ faces: island, colorName });
          }
        }

        faceIslands.sort((a, b) => a.faces.length - b.faces.length);

        for (const island of faceIslands) {
          if (island.faces.length >= minFaceIslandSize) continue;

          const neighborColors = new Map();

          for (const faceIdx of island.faces) {
            for (const neighborFace of faceAdjacency.get(faceIdx) || []) {
              const neighborColor = updatedFaceColors[neighborFace];
              if (neighborColor && neighborColor !== island.colorName) {
                const count = neighborColors.get(neighborColor) || 0;
                neighborColors.set(neighborColor, count + 1);
              }
            }
          }

          if (neighborColors.size === 0) continue;

          let bestColor = null;
          let bestCount = 0;

          for (const [colorName, count] of neighborColors) {
            if (count > bestCount) {
              bestCount = count;
              bestColor = colorName;
            }
          }

          if (bestColor) {
            const newColor = palette.find(c => c.name === bestColor);
            if (newColor) {
              const affectedVertices = new Set();
              for (const faceIdx of island.faces) {
                for (const vertexIdx of faces[faceIdx]) {
                  if (vertices[vertexIdx].color?.name === island.colorName) {
                    vertices[vertexIdx].color = newColor.clone();
                    affectedVertices.add(vertexIdx);
                  }
                }
              }
              if (affectedVertices.size > 0) {
                mergedThisIteration += affectedVertices.size;
              }
            }
          }
        }

        totalMerged += mergedThisIteration;
        if (mergedThisIteration === 0) break;
      }

      log(`  Merged ${totalMerged} vertices via faces in ${iterations} iteration(s)`, 'success');
      return totalMerged;
    }

    function exportOBJ(vertices, originalLines, vertexLineIndices) {
      const lines = [...originalLines];

      let vertexIdx = 0;
      for (const lineIdx of vertexLineIndices) {
        const vertex = vertices[vertexIdx];

        if (vertex.color) {
          lines[lineIdx] = `v ${vertex.x} ${vertex.y} ${vertex.z} ${vertex.color.r.toFixed(6)} ${vertex.color.g.toFixed(6)} ${vertex.color.b.toFixed(6)}`;
        } else {
          lines[lineIdx] = `v ${vertex.x} ${vertex.y} ${vertex.z}`;
        }

        vertexIdx++;
      }

      return lines.join('\n');
    }

    // ========================================================================
    // Main Processing
    // ========================================================================

    async function processOBJ() {
      const numColors = parseInt(document.getElementById('numColors').value);
      const islandThreshold = parseInt(document.getElementById('islandThreshold').value);

      clearLog();
      progressContainer.classList.add('show');
      resultsCard.classList.remove('show');
      logCard.classList.remove('show');
      processBtn.disabled = true;

      const reader = new FileReader();
      
      reader.onload = async (e) => {
        const content = e.target.result;

        try {
          // Step 1: Parse
          updateProgress(10, 'Parsing OBJ file...');
          log('Parsing OBJ file...', 'info');
          await sleep(50);

          const { vertices, vertexLineIndices, originalLines, faces } = parseOBJ(content);
          log(`  ${vertices.length} vertices found`);
          log(`  ${faces.length} faces found`);

          // Step 2: Build adjacency
          updateProgress(20, 'Building adjacency graphs...');
          log('\nBuilding adjacency graphs...', 'info');
          await sleep(50);

          const vertexAdjacency = buildVertexAdjacency(vertices.length, faces);

          // Step 3: Extract colors
          const colors = vertices.filter(v => v.color !== null).map(v => v.color);
          log(`  ${colors.length} vertices with colors`);

          if (colors.length === 0) {
            log('\nNo vertex colors found!', 'error');
            updateProgress(100, 'Error: No colors found');
            return;
          }

          // Step 4: Select palette
          updateProgress(30, 'Selecting best colors...');
          log('\nSelecting best colors...', 'info');
          await sleep(50);

          const palette = selectBestColors(colors, COLOR_POOL, numColors);

          log('\nSelected palette:', 'highlight');
          palette.forEach((c, i) => log(`  ${i + 1}. ${c.name} ${c.toHex()}`));

          // Step 5: Remap
          updateProgress(50, 'Remapping colors...');
          log('\nRemapping colors...', 'info');
          await sleep(50);

          remapColors(vertices, palette);

          // Step 6: Merge islands
          updateProgress(60, 'Merging small islands...');
          log('\nMerging small vertex islands...', 'info');
          await sleep(50);

          mergeSmallIslands(vertices, vertexAdjacency, islandThreshold, palette);

          // Step 7: Merge isolated faces
          updateProgress(80, 'Merging isolated faces...');
          log('\nMerging isolated faces...', 'info');
          await sleep(50);

          const faceAdjacency = buildFaceAdjacency(faces);
          const minFaceIslandSize = Math.max(2, Math.ceil(islandThreshold / 3));
          mergeIsolatedFaces(vertices, faces, faceAdjacency, minFaceIslandSize, palette);

          // Step 8: Export
          updateProgress(90, 'Generating output...');
          log('\nGenerating output...', 'info');
          await sleep(50);

          processedContent = exportOBJ(vertices, originalLines, vertexLineIndices);

          // Final stats
          const finalStats = {};
          palette.forEach(c => finalStats[c.name] = 0);
          for (const v of vertices) {
            if (v.color) finalStats[v.color.name]++;
          }

          log('\nFinal distribution:', 'highlight');
          for (const [name, count] of Object.entries(finalStats)) {
            if (count > 0) {
              log(`  ${name}: ${count} vertices`);
            }
          }

          // Update UI
          updateProgress(100, 'Done!');
          log('\n‚úì Processing complete!', 'success');

          displayResults(palette, finalStats);

        } catch (error) {
          log(`\nError: ${error.message}`, 'error');
          console.error(error);
        }

        processBtn.disabled = false;
      };

      reader.readAsText(loadedFile);
    }

    function updateProgress(percent, text) {
      progressFill.style.width = `${percent}%`;
      progressText.textContent = text;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function displayResults(palette, stats) {
      statsGrid.innerHTML = '';

      for (const color of palette) {
        const count = stats[color.name] || 0;
        if (count > 0) {
          const div = document.createElement('div');
          div.className = 'stat-item';
          div.innerHTML = `
            <div class="color-preview" style="background: ${color.toHex()}"></div>
            <div class="name">${color.name}</div>
            <div class="count">${count.toLocaleString()} vertices</div>
          `;
          statsGrid.appendChild(div);
        }
      }

      resultsCard.classList.add('show');
      logCard.classList.add('show');
    }

    // ========================================================================
    // Event Listeners
    // ========================================================================

    processBtn.addEventListener('click', processOBJ);

    downloadBtn.addEventListener('click', () => {
      if (!processedContent) return;

      const blob = new Blob([processedContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = loadedFile.name.replace('.obj', '_clamped.obj');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
